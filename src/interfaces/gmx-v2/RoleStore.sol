// SPDX-License-Identifier: BUSL-1.1

pragma solidity ^0.8.0;

import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";
import "./EnumerableValues.sol";
import "./Role.sol";
import "./Errors.sol";

/**
 * @title RoleStore
 * @dev Stores roles and their members.
 */
contract RoleStore {
  using EnumerableSet for EnumerableSet.AddressSet;
  using EnumerableSet for EnumerableSet.Bytes32Set;
  using EnumerableValues for EnumerableSet.AddressSet;
  using EnumerableValues for EnumerableSet.Bytes32Set;

  EnumerableSet.Bytes32Set internal roles;
  mapping(bytes32 => EnumerableSet.AddressSet) internal roleMembers;
  // checking if an account has a role is a frequently used function
  // roleCache helps to save gas by offering a more efficient lookup
  // vs calling roleMembers[key].contains(account)
  mapping(address => mapping(bytes32 => bool)) roleCache;

  modifier onlyRoleAdmin() {
    if (!hasRole(msg.sender, Role.ROLE_ADMIN)) {
      revert Errors.Unauthorized(msg.sender, "ROLE_ADMIN");
    }
    _;
  }

  constructor() {
    _grantRole(msg.sender, Role.ROLE_ADMIN);
  }

  /**
   * @dev Grants the specified role to the given account.
   *
   * @param account The address of the account.
   * @param roleKey The key of the role to grant.
   */
  function grantRole(address account, bytes32 roleKey) external onlyRoleAdmin {
    _grantRole(account, roleKey);
  }

  /**
   * @dev Revokes the specified role from the given account.
   *
   * @param account The address of the account.
   * @param roleKey The key of the role to revoke.
   */
  function revokeRole(address account, bytes32 roleKey) external onlyRoleAdmin {
    _revokeRole(account, roleKey);
  }

  /**
   * @dev Returns true if the given account has the specified role.
   *
   * @param account The address of the account.
   * @param roleKey The key of the role.
   * @return True if the account has the role, false otherwise.
   */
  function hasRole(address account, bytes32 roleKey) public view returns (bool) {
    return roleCache[account][roleKey];
  }

  /**
   * @dev Returns the number of roles stored in the contract.
   *
   * @return The number of roles.
   */
  function getRoleCount() external view returns (uint256) {
    return roles.length();
  }

  /**
   * @dev Returns the keys of the roles stored in the contract.
   *
   * @param start The starting index of the range of roles to return.
   * @param end The ending index of the range of roles to return.
   * @return The keys of the roles.
   */
  function getRoles(uint256 start, uint256 end) external view returns (bytes32[] memory) {
    return roles.valuesAt(start, end);
  }

  /**
   * @dev Returns the number of members of the specified role.
   *
   * @param roleKey The key of the role.
   * @return The number of members of the role.
   */
  function getRoleMemberCount(bytes32 roleKey) external view returns (uint256) {
    return roleMembers[roleKey].length();
  }

  /**
   * @dev Returns the members of the specified role.
   *
   * @param roleKey The key of the role.
   * @param start the start index, the value for this index will be included.
   * @param end the end index, the value for this index will not be included.
   * @return The members of the role.
   */
  function getRoleMembers(bytes32 roleKey, uint256 start, uint256 end) external view returns (address[] memory) {
    return roleMembers[roleKey].valuesAt(start, end);
  }

  function _grantRole(address account, bytes32 roleKey) internal {
    roles.add(roleKey);
    roleMembers[roleKey].add(account);
    roleCache[account][roleKey] = true;
  }

  function _revokeRole(address account, bytes32 roleKey) internal {
    roleMembers[roleKey].remove(account);
    roleCache[account][roleKey] = false;

    if (roleMembers[roleKey].length() == 0) {
      if (roleKey == Role.ROLE_ADMIN) {
        revert Errors.ThereMustBeAtLeastOneRoleAdmin();
      }
      if (roleKey == Role.TIMELOCK_MULTISIG) {
        revert Errors.ThereMustBeAtLeastOneTimelockMultiSig();
      }
    }
  }
}
